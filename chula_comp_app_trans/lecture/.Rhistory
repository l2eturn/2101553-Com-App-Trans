diamonds_ok %>% group_by(cut) %>% summarise(num = n(),
avgprice_carat = mean(price/carat),
Q1 = quantile(price,0.25))
ggplot(by_clarity, aes(clarity, mean)) +
geom_linerange(aes(ymin = lq, ymax = uq)) +
geom_line(aes(group = 1), colour = "grey50") +
geom_point(aes(size = n))
# Print out by_clarity
by_clarity
# Print out by_clarity
by_clarity
# Print out by_clarity
by_cut
ggplot(by_clarity, aes(clarity, mean)) +
geom_linerange(aes(ymin = lq, ymax = uq)) +
geom_line(aes(group = 1), colour = "grey50") +
geom_point(aes(size = n))
# Print out by_clarity
by_clarity
# Include the number of observations in each group, and the upper and lower quartiles in the average price
by_clarity <- diamonds_ok %>% group_by(cut) %>% summarise(num = n(),
avgprice_carat = mean(price/carat),
Q1 = quantile(price,0.25))
# Print out by_clarity
by_clarity
# Plot by_clarity
ggplot(by_clarity, aes(clarity, mean)) +
geom_linerange(aes(ymin = lq, ymax = uq)) +
geom_line(aes(group = 1), colour = "grey50") +
geom_point(aes(size = n))
knitr::opts_chunk$set(echo = TRUE)
# Call required packages, ex. "readxl", "tidyverse"
if(!require(readxl)){install.packages("readxl")}
if(!require(tidyverse)){install.packages("tidyverse")}
if(!require(rcompanion)){install.packages("rcompanion")}
if(!require(DescTools)){install.packages("DescTools")}
if(!require(Hmisc)){install.packages("Hmisc")}
if(!require(corrplot)){install.packages("corrplot")}
if(!require(formatR)){install.packages("formatR")}
# Read CSV file with `read_csv`
unemp_wide <- read_csv("./Data/unemployment.csv", show_col_types = FALSE)
# Change from wide to long format (Cartesian to Indexed)
unemp_long <- gather(unemp_wide, key = "year", value = "unemp", `2006`:`2015`)
# Alternatively, we could gather all columns except month
# Then, arrange by month and remove NA
unemp_long2 <-
unemp_long2
# Read CSV file with `read_csv`
unemp_wide <- read_csv("./Data/unemployment.csv", show_col_types = FALSE)
# Read CSV file with `read_csv`
unemp_wide <- read_csv("./Data/unemployment.csv", show_col_types = FALSE)
unemp_wide
unemp_long <- gather(unemp_wide, key = "year", value = "unemp", `2006`:`2015`)
unemp_long
unemp_wide
# Alternatively, we could gather all columns except month
# Then, arrange by month and remove NA
unemp_long2 <- na.omit(unemp_long)
unemp_long2
unemp_long
unemp_long2
unemp_long2 <- na.omit(unemp_long) %>% gather(unemp_wide, key = "year", value = "unemp", -"month", "2006":"2015")
unemp_long2 <- na.omit(unemp_long) %>% gather(unemp_wide, key = "year", value = "unemp", -"month")
gather(unemp_wide, key = "year", value = "unemp", -"month")
unemp_long2
unemp_long2 <- gather(unemp_wide, key = "year", value = "unemp", -"month") %>% na.omit(unemp_long)
unemp_long2
gather(unemp_wide, key = "year", value = "unemp", -"month")
# Alternatively, we could gather all columns except month
# Then, arrange by month and remove NA
unemp_long2 <- gather(unemp_wide, key = "year", value = "unemp", -"month") %>% na.omit(unemp_long) %>% arrange("month")
unemp_long2 <- gather(unemp_wide, key = "year", value = "unemp", -"month") %>% na.omit(unemp_long) %>% arrange("month")
unemp_long2
unemp_long3 <- pivot_longer(unemp_wide, names_to = "year", values_to = "unemp", `2006`:`2015`)
unemp_long3
weather_long <- dplyr::tibble(
day = rep(1:3, 2),
obs = rep(c("temp", "rain"), each = 3),
val = c(c(23, 22, 20), c(0, 0, 5))
)
weather_long
weather_long
# Change from long to wide format (Indexed to Cartesian)
weather_wide <- spread(weather_long, key = "obs",value ="val" )
# Change from long to wide format (Indexed to Cartesian)
weather_wide <- spread(weather_long, key = "obs",value ="val" )
weather_wide
weather_wide
# Print out trt
trt <- separate(trt, "var", c("time","treatment"), "_")
trt <- dplyr::tibble(
var = paste0(rep(c("beg", "end"), each = 3), "_", rep(c("a", "b", "c"))),
val = c(1, 4, 2, 10, 5, 11)
)
# Print out trt
trt <- separate(trt, "var", c("time","treatment"), "_")
# Print out trt
trt <- separate(trt, "var", c("time","treatment"), "_")
# Print out trt
trt <- separate(trt, "var", c("time","treatment"), "_")
trt
trt
trt <- dplyr::tibble(
var = paste0(rep(c("beg", "end"), each = 3), "_", rep(c("a", "b", "c"))),
val = c(1, 4, 2, 10, 5, 11)
)
trt
trt2 <-  separate(trt, "var", c("time","treatment"), "_")
trt2
trt
trt2 <-  separate(trt, "var", c("time","treatment"), "_")
trt2
trt
trt <- dplyr::tibble(
var = paste0(rep(c("beg", "end"), each = 3), "_", rep(c("a", "b", "c"))),
val = c(1, 4, 2, 10, 5, 11)
)
trt
trt2 <-  separate(trt, "var", c("time","treatment"), "_")
trt2
trt2
View(trt)
# Spread with pivot_wider
trt3 <- spread(trt2,"time","val"
# Spread with pivot_wider
trt3 <- spread(trt2,"time","val")
trt3 <- spread(trt2,"time","val")
trt3
View(trt2)
View(trt3)
View(trt2)
View(trt3)
View(trt2)
View(trt3)
View(trt2)
View(trt3)
View(trt2)
View(trt3)
View(trt2)
knitr::opts_chunk$set(echo = TRUE)
# Call required packages, ex. "readxl", "tidyverse"
if(!require(readxl)){install.packages("readxl")}
if(!require(tidyverse)){install.packages("tidyverse")}
if(!require(RCurl)){install.packages("RCurl")}
stat_score <- list(S1 = c(89, 85, 85, 86, 88, 89, 86, 82, 96, 85,
93, 91, 98, 87, 94, 77, 87, 98, 85, 89,
95, 85, 93, 93, 97, 71, 97, 93, 75, 68,
98, 95, 79, 94, 98, 95),
S2 = c(60, 98, 94, 95, 99, 97, 100, 73, 93, 91,
98, 86, 66, 83, 77, 97, 91, 93, 71, 91,
95, 100, 72, 96, 91, 76, 100, 97, 99, 95,
97, 77, 94, 99, 88, 100, 94, 93, 86),
S3 = c(95, 86, 90, 90, 75, 83, 96, 85, 83, 84,
81, 98, 77, 94, 84, 89, 93, 99, 91, 77,
95, 90, 91, 87, 85, 76, 99, 99, 97, 97,
97, 77, 93, 96, 90, 87, 97, 88),
S4 = c(67, 93, 63, 83, 87, 97, 96, 92, 93, 96,
87, 90, 94, 90, 82, 91, 85, 93, 83, 90,
87, 99, 94, 88, 90, 72, 81, 93, 93, 94,
97, 89, 96, 95, 82, 97))
View(stat_score)
knitr::opts_chunk$set(echo = TRUE)
# Create a vector with 4 mangoes and 6 apples
c(mango = 4,apple = 6)
# Use the "setNames" function to name the vector "my_fruit"
my_fruit <- c(4,6,8)
# Use the "setNames" function to name the vector "my_fruit"
my_fruit <- c(4,6,8)
my_fruit
fruit_name <- c('mango','apple')
fruit_name
setNames(my_fruit, fruit_name)
z <- c(12, 15, 3, 22);
# Sort the vector "z" in ascending order with the "sort" function
sort(z);
# Sort the vector "z" in descending order with the "sort" function
sort(z, decreasing = TRUE);
arr <- c(z[3], z[1], z[2], z[4]);
x <- c(1, 5)
y <- c(4, 0, 1, 3)
for (i in x)
{
print(i %in% y);
}
x[c(TRUE, FALSE)]
for (i in x)
{
print(i %in% y);
}
x[c(TRUE, FALSE)]
x[x %in% y]
all(x %in% y)
x[x %in% y]
all(x %in% y)
x[x %in% y]
x[c(TRUE, FALSE)]
x[x %in% y]
x[c(TRUE, FALSE)]
my_month <- month.abb
my_month
# Access different data of "my_month"
# First element
my_month[1];
# Third and fourth element
my_month[3:4]
# Fifth and seventh element
my_month[c(3,7)];
my_month[seq(2,length(my_month),by = 2)]
my_month[seq(1,length(my_month),by = 2)]
my_month <- month.abb
Spain_temp <- c(22.52, 18.70, 19.61, 22.79, 29.38, 30.19,
33.16, 36.97, 33.29, 28.98, 24.31, 22.43)
my_month[Spain_temp > 30]
my_data <- 1:12
my_data
matrix(my_data, nco = 2)
event_day <- c("Friday", "Tuesday", "Thursday",
"Monday", "Wednesday", "Monday",
"Wednesday", "Monday", "Monday",
"Wednesday", "Sunday", "Saturday")
event_day
aa <- factor(event_day,level = unique(event_day))
aa
table(aa)
# Convert the data into factor and get it categorized for further analysis
#factor(city)
city_1 <- factor(city)
# You have the following data stored in a numeric vector
city <- c(3, 2, 1, 4, 3, 2)
# Convert the data into factor and get it categorized for further analysis
#factor(city)
city_1 <- factor(city)
city_1
# Change factor labels of the levels
city_factor <- factor(city, labels = c("Bangkok","Chiangmai","Songkhla","Khonkean"))
city_factor
table(city_factor)
my_df <- data.frame(city = city_factor, salary = sample(20:50, 6))
my_df
knitr::opts_chunk$set(echo = TRUE)
df_data <- data.frame(col1 = 1:10, col2 = 11:20)
df_data
# Check the default row names of my_df
rownames(df_data)
# Check the default row names of my_df
rownames(df_data)
rownames(df_data)
df_data
colnames(df_data)
df_data
# Set the row names to my_df with a character vector with elements "Row_X"
# Hint: use the "paste" function to concatenate vectors after converting to character.
rownames(df_data) <- paste("Row_",1:10,sep = '')
df_data
rownames(df_data) <- paste("Row_",1:10,sep = '')
df_data
df_data <- data.frame(col1 = 1:10, col2 = 11:20)
df_data
# Check the default row names of my_df
rownames(df_data)
rownames(df_data) <- paste("Row_",1:10,sep = '')
# Print out "Jan is the 1st month of the year." to "Dec is the 12th month of the year."
aa <- paste(1:12, c("st","nd","rd",rep("th",9)),sep = '')
paste(month.abb,"is the",aa,"month of the year")
# Check the column names of df_data
colnames(df_data)
# Change the column names of my_df to "Column_1" and "Column_2"
colnames(df_data) <- c("Colum_1","Colum_2")
# Add the third column to my_df with the elements 21:30 and set its column name to "Column_3"
df_data <- cbind(df_data,Colum_3 = 21:30)
df_data
rownames(df_data)
# Remove row names of df_data
rownames(df_data) <- NULL
rownames(df_data) <- NULL
rownames(df_data
df_data
knitr::opts_chunk$set(echo = TRUE)
if(!require(tidyverse)){install.packages("tidyverse")}
x <- c(one = 1, two = 2)
x
# Single square brackets = Maintains the name of the element
x[1]
# Double square brackets = Simplified output
x[[1]]
# Access observations out of the bounds
# Single square brackets
x[6]
# Double square brackets
x[[6]]
my_vector <- c(15, 21, 17, 25, 12, 51)
# Second and fifth elements
my_vector[2];
my_vector <- c(15, 21, 17, 25, 12, 51)
# Second and fifth elements
my_vector[2];
my_vector[5];
# Second element twice
rep(my_vector[2],2)
# All values except the fourth and fifth
my_vector[c(-4,-5)]
# First, third, fourth and sixth values using boolean indices
my_vector[c(T,F,T,T,F,T)]
my_vector[] <- 1
my_vector
set.seed(24)
set.seed(24)
my_df <- data.frame(x = 1:10,
y = 11:20,
z = 3:12,
w = sample(c("Group 1", "Group 2"), 10, replace = TRUE))
head(my_df)
# Select the second column and simplify as vector
my_df[[2]]
set.seed(24)
my_df <- data.frame(x = 1:10,
y = 11:20,
z = 3:12,
w = sample(c("Group 1", "Group 2"), 10, replace = TRUE))
head(my_df)
# Select the second column and simplify as vector
my_df[[2]]
my_df[, 2]   # Equivalent
# Select the second column and simplify as vector
my_df[[2]]
my_df[, 2]   # Equivalent
# Select the second column with column and row names
my_df[2]
my_df[, 2, drop = FALSE] # Equivalent
my_values <- c(12, 14, 16)
set.seed(24)
my_df <- data.frame(x = 1:10,
y = 11:20,
z = 3:12,
w = sample(c("Group 1", "Group 2"), 10, replace = TRUE))
head(my_df)
# Select the second column and simplify as vector
my_df[[2]]
my_df[, 2]   # Equivalent
my_df[["y"]] # Equivalent
my_df[, c(FALSE, TRUE, FALSE, FALSE)] # Equivalent
# Select the second column with column and row names
my_df[2]
my_df[, 2, drop = FALSE] # Equivalent
my_df["y"]               # Equivalent
my_df[c(FALSE, TRUE, FALSE, FALSE)] # Equivalent
# Select the first and third column
# Use the dollar sign ($) to select the column 'y' and 'w'
my_df <- data.frame(x = 1:10,
y = 11:20,
z = 3:12,
w = sample(c("Group 1", "Group 2"), 10, replace = TRUE))
my_df
# Select the fourth, sixth and ninth rows of my_df
my_df[c(4,6,9),]
my_df
# Select the fourth, sixth and ninth rows of my_df
my_df[c(4,6,9),]
my_values <- c(12, 14, 16)
# Subset rows of my_df based on my_values
my_df[[my_values]]
# Subset rows of my_df based on my_values
my_df[my_values]
my_values <- c(12, 14, 16)
# Subset rows of my_df based on my_values
my_df[my_values]
my_df
# Subset rows of my_df based on my_values
my_df[[my_values]]
my_df
# Subset rows of my_df based on my_values
my_df[(my_df$y %in% my_values),]
# Select the opposite of the above result
my_df[(!(my_df$y) %in% my_values),]
# Values where column z is greater than 5
my_df(my_df$z > 5)
# Values where column z is greater than 5
my_df(my_df$z > 5,)
my_df
# Values where column z is greater than 5
my_df(my_df$z > 5,)
# Values where column z is greater than 5
my_df[my_df$z > 5,]
# All values corresponding to Group 1
my_df[my_df$w == "Group 1"]
# All values corresponding to Group 1
my_df[my_df$w == "Group 1",]
# Select all values where 'y' is lower or equal to 14
# and return only the columns "y" and "w"
my_df[my_df$y<=14,select = c("y", "w")]
# Select all values where 'y' is lower or equal to 14
# and return only the columns "y" and "w"
subset(my_df,y <= 14, select = c("y","w"))
# Use multiple subset conditions to select samples where
# 'y' is larger than 6 and the group of the 'w' column is Group 2.
subset(my_df,y > 6 & w == "Group 2", select = c('w'))
dates <- seq(as.Date("2025/8/1"), by = "day", length.out = 10)
my_df_dates <- cbind(dates, my_df)
head(my_df_dates)
as.Date("2025/8/1")
seq(as.Date("2025/8/1"), by = "day", length.out = 10)
dates <- seq(as.Date("2025/8/1"), by = "day", length.out = 10)
my_df_dates <- cbind(dates, my_df)
head(my_df_dates)
a <- c(x = 3, y = 5, x = 1, x = 4, y = 3)
a
my_groups <- c("Group 1", "Group 1", "Group 2", "Group 1", "Group 2")
# New group
my_groups2 <- c("Type 1", "Type 1", "Type 1", "Type 2", "Type 1")
# New group
my_groups2 <- c("Type 1", "Type 1", "Type 1", "Type 2", "Type 1")
# Sample data frame
df <- data.frame(
gender = c("m", "f", "f", "f", "m", "m"),
height = c(171, 164, 165, 170, 179, 180)
)
# Split data frame by gender
split_by_gender <- split(df, df$gender)
print(split_by_gender)
# Split the vector 'a' into 2 vectors
aa <- split(a,c('x','y'))
aa
# Split the vector 'a' into 2 vectors
split(a,f = names(a))
# Split the vector 'a' into 2 vectors
aa <- split(a,f = names(a))
# Split the vector 'a' into 2 vectors
aa <- split(a,f = names(a))
aa
aa <- split(a,c('x','y'))
aa
my_
aa <- split(a,c('x','y'))
aa
aa <- split(a)
aa <- split(a,f =  names(a))
# Split the vector 'a' using the vecter 'my_groups'
aaa <- split(a,f = names(my_groups))
# Split the vector 'a' using the vecter 'my_groups'
aaa <- split(a,f = my_groups)
aaa
aaaa <- split(a, f = list(my_groups, my_groups2))
aaaa
# Remove the empty elements and change the separator to ":"
split(a, f = list(my_groups, my_groups2), drop = TRUE, sep = ":")
aaaa
# Remove the empty elements and change the separator to ":"
split(a, f = list(my_groups, my_groups2), drop = TRUE, sep = ":")
# Unsplit 'vec_split' to recover the original vector
vec_split <- split(a, f = names(a))
unsplit(vec_split, f = names(a))
set.seed(123)
data(CO2)
data(CO2)
set.seed(123)
data(CO2)
my_df2 <- CO2[sample(1:nrow(CO2), 10), ]
my_df2 <- CO2[sample(1:nrow(CO2), 10), ]
my_df2
my_df2
# Use the split function to split the data frame in groups based on the "Treatment" variable
aa <- split(my_df2, f = my_df2$"Treatment")
aa
my_df2
aa
# Use the split function to split the data frame in groups based on the "Treatment" variable
aa <- split(my_df2, f = my_df2$"Treatment")
aa <- split(my_df2, f = my_df2$"Treatment")
aa
# Create the split of the sample data frame with Type and Treatment columns.
aa1 <- split(my_df2, f = my_df2$c("Type","Treatment"))
# Create the split of the sample data frame with Type and Treatment columns.
aa1 <- split(my_df2, f = list(my_df2&"Type",my_df2&"Treatment"))
# Use the split function to split the data frame in groups based on the "Treatment" variable
aa <- split(my_df2, f = my_df2$Treatment)
aa
# Create the split of the sample data frame with Type and Treatment columns.
aa1 <- split(my_df2, f = list(my_df2&Type,my_df2&Treatment))
aa
my_df2
my_df2 <- CO2[sample(1:nrow(CO2), 10), ]
my_df2
# Create the split of the sample data frame with Type and Treatment columns.
aa1 <- split(my_df2, f = list(my_df2&Type,my_df2&Treatment))
# Create the split of the sample data frame with Type and Treatment columns.
aa2 <- split(my_df2, f = list(my_df2$Type, my_df2$Treatment))
aa2
# Recover the original data frame with the unsplit function
unsplit(df_split, f = my_df2$Treatment)
# Recover the original data frame with the unsplit function
unsplit(aa2, f = my_df2$Treatment)
my_sampleX <- -5:5
range(my_sampleX)
# Sample data
my_sampleX <- -5:5
range(my_sampleX)
# Cut the range of sample into 2 intervals (categories) with the same length
cut(my_sampleX, breaks = 2)
# Cut the range of sample into 2 intervals: (-6,2] (2,5]
cut(my_sampleX, breaks = c(-6, 2, 5))
# Cut the range of sample into 2 intervals: [-5,2) [2,6)
cut(my_sampleX, breaks = c(-5, 2, 6), right = FALSE)
my_sampleY <- c(12, 1, 25, 12, 65, 2, 6, 17)
# Cut the range of sample into 5 intervals with the break points
# 0, 3, 12, 15, 20, 80
# and change the labels of the output factor to
# "First", "Second", "Third", "Fourth", "Fifth", respectively
categorized_data <- cut(my_sampleY,
breaks = c(0, 3, 12, 15, 20, 80),
labels = c("First", "Second", "Third", "Fourth", "Fifth"))
# Create the data frame showing the original values and categorized intervals
data.frame(Original_Value = my_sampleY, Category = categorized_data)
